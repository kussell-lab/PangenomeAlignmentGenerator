package main

import (
	"bufio"
	"fmt"
	"github.com/alecthomas/kingpin"
	"github.com/kussell-lab/biogo/pileup"
	"github.com/kussell-lab/biogo/seq"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"time"
)

func main() {
	app := kingpin.New("MapReads2Pangenome", "Map a list of SRA files to a pangenome reference genome generated by Roary.")
	app.Version("201223")
	sraFile := app.Arg("SRA_list", "file contains a list of SRA numbers corresponding to fastqs").String()
	refgen := app.Arg("refgen", "path to the reference genome").String()
	wrkdir := app.Arg("wrkdir", "Working directory holding 1) SRA files, 2) ref gen FASTA, and output directory for aligned genomes").String()
	//outdir := app.Arg("outdir", "output directory for aligned genomes").String()
	//appendix := app.Flag("appendix", "appendix for aligned genomes (default .pileup.fasta)").Default(".pileup.fasta").String()
	//showProgress := app.Flag("progress", "showing progress").Default("false").Bool()
	ncpu := app.Flag("num_cpu", "number of cpus").Default("0").Int()
	numAligners := app.Flag("aligners", "number of threads working on aligning SRAs to the pangenome reference genome").Default("0").Int()
	kingpin.MustParse(app.Parse(os.Args[1:]))

	if *ncpu <= 0 || *ncpu > runtime.NumCPU() {
		*ncpu = runtime.NumCPU()
	}
	runtime.GOMAXPROCS(*ncpu)
	if *numAligners == 0 {
		*numAligners = *ncpu
	} else if *numAligners > *ncpu {
		*numAligners = *ncpu
	}
	start := time.Now()

	reads := readSamples(*sraFile)

	if len(reads) < *numAligners {
		*numAligners = len(reads)
	}
	alignGenomeAll(reads, *wrkdir, *refgen, *numAligners)

	duration := time.Since(start)
	fmt.Println("Time to map reads to pangenome reference genome", duration)

}

func alignGenomeAll(reads []string, wrkdir string, refgen string, numAligners int) {
	// MD5All closes the done channel when it returns; it may do so before
	// receiving all the values from c and errc.
	done := make(chan struct{})
	defer close(done)

	// use smalt and samtools to index the pangenome reference genome
	cmd := exec.Command("smalt", "index", refgen, refgen)
	//run smalt index
	if stdoutStderr, err := cmd.CombinedOutput(); err != nil {
		log.Fatalf("Error using smalt index: ", err)
	} else {
		fmt.Printf("%s\n", stdoutStderr)

	}
	cmd = exec.Command("samtools", "faidx", refgen)
	//run samtools faidx
	if stdoutStderr, err := cmd.CombinedOutput(); err != nil {
		log.Fatalf("Error using samtools faidx: ", err)
	} else {
		fmt.Printf("%s\n", stdoutStderr)

	}

	//make a channel for SRA reads which closes when we're fresh outta reads
	SRAchan := getReads(done, reads)

	//start a fixed number of goroutines to align genomes and write them to separate FASTA files
	//make a results channel
	resChan := make(chan result)
	var wg sync.WaitGroup

	for i := 0; i < numAligners; i++ {
		wg.Add(1)
		go aligner(done, SRAchan, resChan, wrkdir, refgen, i, &wg)
	}

	go func() {
		wg.Wait()
		close(resChan)
	}()
	for r := range resChan {
		writeFasta(r.seqs, r.read, wrkdir)
	}
}

//getReads makes a channel for SRA reads which closes when we're fresh out of reads
func getReads(done <-chan struct{}, reads []string) <-chan string {
	SRAchan := make(chan string)

	go func() {
		defer close(SRAchan)
		for _, read := range reads {
			select {
			case SRAchan <- read:
			case <-done:
				return
			}
		}
	}()
	return SRAchan
}

type result struct {
	read string
	seqs chan seq.Sequence
}

//aligner aligns genomes and writes them to FASTA files until either SRAchan or done is closed
func aligner(done <-chan struct{}, reads <-chan string, c chan<- result, wrkdir string, refgen string, id int, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Printf("Aligner %d starting\n", id)
	for read := range reads {
		//command for converting SRA to fastq files
		sra := filepath.Join(wrkdir, read)
		cmd := exec.Command("fasterq-dump", sra, "-O", wrkdir)
		//run fasterq-dump
		if stdoutStderr, err := cmd.CombinedOutput(); err != nil {
			//fmt.Println("Error: ", err)
			log.Fatal(err)
		} else {
			fmt.Printf("%s\n", stdoutStderr)

		}
		////if we've successfully converted to fastq, align the read
		//read1 := filepath.Join(wrkdir, read+"_1.fastq")
		//read2 := filepath.Join(wrkdir, read+"_2.fastq")
		//if fileExists(read1) && fileExists(read2){
		//	alignedRead := alignGenome(read, wrkdir, refgen)
		//	aln := <- alignedRead
		//		}
		alignedRead := alignGenome(read, wrkdir, refgen)
		select {
		case c <- result{read, alignedRead}:
		case <-done:
			return
		}
	}
	fmt.Printf("Aligner %d done\n", id)
}

// alignGenome aligns a sequence to the reference genome and returns a channel of sequences
func alignGenome(read string, wrkdir string, refgen string) chan seq.Sequence {
	//ref := strings.Split(refgen, "/")
	//refname := strings.Split(ref[len(ref)-1], ".f")
	//bam := read + "_" + refname[0]
	cmd := exec.Command("Map2Pangenome", read, wrkdir, refgen)
	//cmd := exec.Command("samtools", "mpileup", "-f", refgen, bam)
	pipe, err := cmd.StdoutPipe()
	if err != nil {
		log.Fatal(err)
	}
	if err := cmd.Start(); err != nil {
		panic(err)
	}
	snpChan := make(chan *pileup.SNP)
	done := make(chan struct{})
	//var snpSlice []pileup.SNP
	go func() {
		defer close(snpChan)
		r := pileup.NewReader(pipe)
		for {
			//working version
			snp, err := r.Read()
			if err != nil {
				if err != io.EOF {
					log.Fatalf("Error when parsing pileup file: %v", err)
				}
				done <- struct{}{}
				break
			}
			snpChan <- snp
		}
	}()
	seqChan := buildConsensusGenome(snpChan, 30, refgen)
	<-done
	if err := cmd.Wait(); err != nil {
		log.Fatalf("Got to the end but there's a problemo: %v", err)
	}
	bamfile := filepath.Join(wrkdir, read+".sorted.bam")
	err = os.Remove(bamfile)
	if err != nil {
		log.Fatalf("problem removing bam file: %s, %v", bamfile, err)
	}
	return seqChan
}

// fileExists checks if a file exists and is not a directory before we
// try using it to prevent further errors.
func fileExists(filename string) bool {
	info, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}

// readSamples return a list of samples from a sample file.
func readSamples(filename string) (samples []string) {
	f, err := os.Open(filename)
	if err != nil {
		log.Fatalf("Error when reading file %s:%v", filename, err)
	}
	defer f.Close()

	r := bufio.NewReader(f)
	for {
		line, err := r.ReadString('\n')

		if err != nil {
			if err != io.EOF {
				log.Fatalf("Error when reading file %s: %v", filename, err)
			} else {
				if err == io.EOF && samples == nil {
					err = fmt.Errorf("no samples in %s\n", filename)
					//fmt.Print(err)
					panic(err)
				}
			}
			break
		}
		samples = append(samples, strings.TrimSpace(line))
	}
	return
}

////aligner aligns genomes and writes them to FASTA files until either SRAchan or done is closed
//func aligner(done <- chan struct{}, reads <- chan string, wrkdir string, refgen string, id int, wg *sync.WaitGroup){
//	defer wg.Done()
//	fmt.Printf("Aligner %d starting\n", id)
//	for read := range reads{
//		//command for converting SRA to fastq files
//		sra := filepath.Join(wrkdir, read)
//		cmd := exec.Command("fasterq-dump", sra, "-O", wrkdir)
//		//run fasterq-dump
//		if stdoutStderr, err := cmd.CombinedOutput(); err != nil {
//			//fmt.Println("Error: ", err)
//			log.Fatal(err)
//		} else {
//			fmt.Printf("%s\n", stdoutStderr)
//
//		}
//		//if we've successfully converted to fastq, align the read
//		read1 := filepath.Join(wrkdir, read+"_1.fastq")
//		read2 := filepath.Join(wrkdir, read+"_2.fastq")
//		if fileExists(read1) && fileExists(read2){
//			pile := read + ".pileup.fasta"
//			alignedRead := alignGenome(read, wrkdir, refgen)
//			//write to a pileup file
//			writeFasta(alignedRead, pile, wrkdir)
//			//will add back in for final version
//			//os.RemoveAll(sra)
//			//os.Remove(read1)
//			//os.Remove(read2)
//		}
//		select {
//		case <- reads:
//			fmt.Print("Received from reads channel")
//		case <- done:
//			return
//		}
//	}
//	fmt.Printf("Aligner %d done\n", id)
//}
